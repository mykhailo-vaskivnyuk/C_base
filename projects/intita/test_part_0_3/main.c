/*----------------------------------------------------------------
 * Алгоритмізація і програмування на мові С.
 * Проміжний тест по темах "Масиви", "Функції" і "Покажчики".
 *----------------------------------------------------------------
 * ITA17
 * Vaskivnyuk Mykhailo
 * 28.06.2017
 *----------------------------------------------------------------
 * IDE: Qt Creator 3.2.1 Основан на Qt 5.3.2 (MSVC 2010, 32 бита)
----------------------------------------------------------------*/

/*- ЗАВДАННЯ -------------------------------------------------------------------
1. Дано три квадратні матриці A, B, C розмірності N x N. Написати програму, яка:
     - визначає "норму" кожної матриці (максимальне за модулем значення серед її елементів);
     - виводить на екран знайдені норми, а також матрицю, норма якої найменша.
   Примітки:
     а) аналіз матриць здійснювати виключно через механізм покажчиків!
     б) вказані дії реалізувати у вигляді окремих функцій.
--------------------------------------------------------------------------------
2. Нехай задано масив цілих чисел:
   int arr[10] = {5, 1, 9, 8, 6, 7, 2, 4, 5, 3};
   Необхідно:
     1) оголосити покажчик на масив покажчиків і виділити під нього пам'ять
        в аналогічній кількості комірок;
     2) заповнити масив покажчиків адресами елементів масиву arr;
     3) здіснити сортування масиву покажчиків таким чином, щоб початкова
        адреса відповідала найменшому елементу масиву arr, а наступні - відповідно,
        значенням елеменів масиву arr за зростанням.
   В якості перевірки правильності сортування - вивести на екран елементи масиву arr,
   доступаючись до них через масив покажчиків.
   Важливо! В процесі вирішення задачі масив arr в жодному разі не сортувати!
------------------------------------------------------------------------------*/

#include <stdio.h>
#include <conio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <time.h>

//-- перерахування для вибору одного із тестового завдання -------------------//
typedef enum
{
    TEST_1      //0
   ,TEST_2      //1
   ,TESTS_END   //2 - кількість елементів перерахування
} eTESTS;

//-- функції для реалізації завдань ------------------------------------------//
void funcTest_1(void);
void funcTest_2(void);

//-- покажчик на вище вказані функції ----------------------------------------//
typedef void (*ptr_funcTest)(void);

//-- функція для вибору одного із завдань ------------------------------------//
void changeTest(eTESTS *);

//-- допоміжні функції для реалізації завдань --------------------------------//
void printArrayInt      (int *, int, int, int array_type, int array_ptr);
//array_type = 0 - звичайний вивід масиву || 1 - транспонований вивід масиву
//array_ptr  = 0 - покажчик на масив      || 1 - покажчик на масив покажчиків
//                                        ||     на елементи масиву

//-- допоміжні функції для реалізації першого завдання -----------------------//
void setArrayInt        (int *,  int, int);
int  getArrayNorma      (int *,  int, int);

//-- допоміжні функції для реалізації другого завдання -----------------------//
void sortPtrArrayInt    (int **, int, bool (*)(int, int));
bool ifMin              (int,    int);

//----------------------------------------------------------------------------//
int main(void)
{
//-- оголошуємо масив покажчиків на тестові функції --------------------------//
    ptr_funcTest  test_functions[TESTS_END] = { [TEST_1] = funcTest_1
                                               ,[TEST_2] = funcTest_2};
    eTESTS        active_test               = TEST_2;

//-- оголошуємо змінну для завершення програми -------------------------------//
    bool          running                   = true;

//----------------------------------------------------------------------------//
    srand(time(0));
    while( running )
    {
        system("cls");
        puts("\0");
//-- виконуємо тестову функцію, на яку вказує індекс active_test -------------//
        test_functions[active_test]();

//-- виводимо меню для продовження, завершення або зміни тестової функції ----//
        puts("\0");
        puts("TO TRY AGAIN PRESS <ENTER>. TO CHANGE TEST - <BACKSPACE>. TO EXIT - OTHER KEY.\n");
        switch( getch() )
        {
            case '\r':
                continue;
            case '\b':
                changeTest(&active_test);
                break;
            default:
                running = false;
        }
    }

    return 0;
}
//----------------------------------------------------------------------------//
//  ТЕСТ 1
//----------------------------------------------------------------------------//
void funcTest_1(void)
{
    printf("%s\n", __FUNCTION__);
//-- змінні для розмірності масивів та їх кількості --------------------------//
    int array_size_N = 5; //(rand() % 6) + 2; //кількість рядків
    int array_size_M = 5; // array_size_N;    //кількість стовпчиків
    int arrays_count = 3; //(rand() % 3) + 2; //кількість масивів NxM

//-- допоміжні змінні --------------------------------------------------------//
    int i = 0;
    int norma_min = 0;

//-- виділяємо память одним блоком для ---------------------------------------//
//-- (arrays_count) масивів розмірністю NxM ----------------------------------//
    typedef int (*ptr_arrays)[array_size_N][array_size_M];
    ptr_arrays arrays = (ptr_arrays)malloc(arrays_count * array_size_N * array_size_M * sizeof(int));

//-- масив для зберігання норм кожного з масивів ----------------------------//
    int * arrays_norma = (int *)malloc(arrays_count * sizeof(int));

//-- заповнюємо масиви випадковими значеннями --------------------------------//
//-- виводимо масиви на екран ------------------------------------------------//
    for(i = 0; i < arrays_count; i++)
    {
        setArrayInt((int *)(arrays + i), array_size_N, array_size_M);
        //arrays[i][0][0] = 0; //для контролю
        printArrayInt((int *)(arrays + i), array_size_N, array_size_M, 0, 0);
    }

//-- визначаємо норми масивів та виводимо їх на екран ------------------------//
//-- визначаємо мінімальну з них ---------------------------------------------//
    for(i = 0; i < arrays_count; i++)
    {
        *(arrays_norma + i) = getArrayNorma((int *)(arrays + i), array_size_N, array_size_M);
        puts("\0");
        printf("NORMA MATR %2d: %3d\n", i + 1, *(arrays_norma + i));

        if(i == 0) norma_min = *arrays_norma;
        else if( norma_min > *(arrays_norma + i) )
            norma_min = *(arrays_norma + i);
    }

//-- виводимо на екран масиви з мінімальною нормою ---------------------------//
    for(i = 0; i < arrays_count; i++)
    {
        if( norma_min != *(arrays_norma + i)) continue;

        puts("\0");
        printf("MATR %2d:\n", i + 1);
        printArrayInt((int *)*(arrays + i), array_size_N, array_size_M, 0, 0);
    }

//-- звільняємо виділену під масиви пам'ять ----------------------------------//
    free(arrays_norma);
    free(arrays);
    return;
}
//----------------------------------------------------------------------------//
//  ТЕСТ 2
//----------------------------------------------------------------------------//

void funcTest_2(void)
{
    printf("%s\n", __FUNCTION__);

//-- заданий масив -----------------------------------------------------------//
    int    array[10]    = {5, 1, 9, 8, 6, 7, 2, 4, 5, 3};
    int    array_size_N = 1;
    int    array_size_M = 10;

//-- оголошуємо масив покажчиків на елементи заданого масиву -----------------//
    int ** ptr_array  = (int **)malloc(array_size_M * sizeof(int *));
    int    i          = 0;

//-- заповнюємо масив покажчиків адресами на елементи заданого масиву --------//
    *ptr_array = array;
    for(i = 1; i < array_size_M; i++) *(ptr_array + i) = *ptr_array + i;

//-- виводимо на екран заданий масив -----------------------------------------//
    printArrayInt(array,     array_size_N, array_size_M, 0, 0);

//-- сортуємо масив покажків на елементи заданого масиву ---------------------//
    sortPtrArrayInt(ptr_array, array_size_M, ifMin);

//-- виводимо на екран заданий масив ПОВТОРНО --------------------------------//
    printArrayInt(array,     array_size_N, array_size_M, 0, 0);

//-- виводимо на екран масив покажчиків елементи заданого масивуна -----------//
    printArrayInt((int *)ptr_array, array_size_N, array_size_M, 0, 1);

//-- звільняємо виділену під масиви пам'ять ----------------------------------//
    free(ptr_array);

    return;
}
//----------------------------------------------------------------------------//
//  СПІЛЬНІ ФУНКЦІЇ
//----------------------------------------------------------------------------//
void changeTest(eTESTS * active_test)
{
    if( ++*active_test >= TESTS_END )
        *active_test = TEST_1;
}
//----------------------------------------------------------------------------//
void printArrayInt(int * array, int array_size_N, int array_size_M, int array_type, int array_ptr)
{
    int i     = 0;
    int j     = 0;
    int index = 0;
    int value = 0;

    puts("\0");
    for(i = 0; i < array_size_M; i++)
        printf("%4d ", i + 1);
    puts("\0");

    puts("\0");
    for(i = 0; i < array_size_N; i++)
    {
        for(j = 0; j < array_size_M; j++)
        {
            index = array_type ? (j * array_size_N + i) : (i * array_size_M + j);
            value = array_ptr  ? **((int **)array + index) : *(array + index);
            printf("%4d ", value);
        }
        puts("\0");
    }
    puts("\0");
}
//----------------------------------------------------------------------------//
//  ДОПОМІЖНІ ФУНКЦІЇ ДЛЯ ПЕРШОГО ЗАВДАННЯ
//----------------------------------------------------------------------------//
void setArrayInt(int * array, int array_size_N, int array_size_M)
{
    int counter = array_size_N * array_size_M;
    while( counter-- )
        *(array + counter) = (rand() % 100) * (rand() % 2 ? -1 : 1);
}
//----------------------------------------------------------------------------//
int getArrayNorma(int * array, int array_size_N, int array_size_M)
{
    int counter = array_size_N * array_size_M;
    int norma = 0;
    while( counter-- )
    {
        if( norma < abs(*(array + counter)) )
            norma = abs(*(array + counter));
    }
    return norma;
}
//----------------------------------------------------------------------------//
//  ДОПОМІЖНІ ФУНКЦІЇ ДЛЯ ДРУГОГО ЗАВДАННЯ
//----------------------------------------------------------------------------//
void sortPtrArrayInt(int ** array, int array_size, bool (*condition)(int, int))
{
   int   i       = 0;
   int   j       = 0;
   int * tmp_int = NULL;

   for(i = 1; i < array_size; i++)
   {
       for(j = 0; j < array_size - i; j++)
       {
           if( condition(**(array + j), **(array + j + 1)) )
           {
               tmp_int = *(array + j);
               *(array + j) = *(array + j + 1);
               *(array + j + 1) = tmp_int;
           }
       }
   }
}

bool ifMin(int a, int b)
{   return a > b; }
//----------------------------------------------------------------------------//
//  END
//----------------------------------------------------------------------------//
