/*----------------------------------------------------------------
 * Алгоритмізація і програмування на мові С.
 * Заняття 7. Файли з довільним доступом.
 * Частина 3. Обробка вмісту двійкових файлів.
 *----------------------------------------------------------------
 * ITA17
 * Vaskivnyuk Mykhailo
 * 30.05.2017
 *----------------------------------------------------------------
 * IDE: Qt Creator 3.2.1 Основан на Qt 5.3.2 (MSVC 2010, 32 бита)
----------------------------------------------------------------*/

/* ЗАВДАННЯ
На основі описання основних функцій доступу до бінарних файлів - склади програму,
яка реалізує наступні пункти:
1) вибрати в якості “піддослідного” довільний файл на твоєму ПК
(файл одного з типів, перелічених в частині 1);
2) реалізуй наступні кроки:
   - через файлову змінну встановити зв’язок з вибраним файлом (в будь-якому режимі);
   - оголосити змінну a одного з чисельних типів;
   - встановити покажчик поточної позиції у файловому потоці на початок, вивести його значення на екран;
   - перемістити покажчик вперед на довжину (кількість байт) змінної a (початок відліку - SEEK_CUR),
вивести на екран поточну позицію;
   - перемістити покажчик вперед на довжину змінної a (початок відліку - SEEK_SET),
вивести на екран поточну позицію (результат порівняти з попереднім, зробити висновки);
   - перемістити покажчик назад на довжину змінної a (початок відліку - SEEK_CUR),
виводить на екран поточну позицію (результат порівняти з отриманими раніше, зробити висновки).
*/

#include <stdio.h>

int main(void)
{
    FILE * inFile;
    char * file_name = "test.jpg";
    unsigned int test_int = 0;
    size_t int_size = sizeof(int);

    inFile = fopen(file_name, "rb");
    if(!inFile)
    {
       printf("FILE %s DOES NOT EXIST!\n", file_name);
       return 0;
    }

/*---------------------------------------------------------------------
    встановити покажчик поточної позиції у файловому потоці на початок,
    вивести його значення на екран; */

    rewind(inFile);
    printf("BEGIN OF FILE:              %05ld\n", ftell(inFile));\

//---------------------------------------------------------------------

/*---------------------------------------------------------------------
    перемістити покажчик вперед на довжину (кількість байт) змінної a
    (початок відліку - SEEK_CUR),
    вивести на екран поточну позицію; */

    fseek(inFile, int_size, SEEK_CUR);
    printf("GO OVER %d BYTES (SEEK_CUR): %05ld\n", int_size, ftell(inFile));

//---------------------------------------------------------------------

/*---------------------------------------------------------------------
    перемістити покажчик вперед на довжину змінної a (початок відліку - SEEK_SET),
    вивести на екран поточну позицію
    (результат порівняти з попереднім, зробити висновки); */

    fseek(inFile, int_size, SEEK_SET);
    printf("GO OVER %d BYTES (SEEK_SET): %05ld\n", int_size, ftell(inFile));

//---------------------------------------------------------------------

/*---------------------------------------------------------------------
   перемістити покажчик назад на довжину змінної a (початок відліку - SEEK_CUR),
   виводить на екран поточну позицію
   (результат порівняти з отриманими раніше, зробити висновки). */

    fseek(inFile, -sizeof(int), SEEK_CUR);
    printf("GO BACK %d BYTES (SEEK_CUR): %05ld\n", int_size, ftell(inFile));

//---------------------------------------------------------------------

    test_int = fread(&test_int, int_size, 1, inFile);
    printf("FIRST VALUE HAVE BEEN READ: %05u\n", test_int);
    printf("CURENT POSITION IS:         %05ld\n", ftell(inFile));

    fclose(inFile);

    return 0;
}
